use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;

// This test will verify that hex ranges are parsed correctly
#[test]
fn test_hex_range_generation() {
    let temp_dir = TempDir::new().unwrap();
    let workspace_root = temp_dir.path();
    
    // Create a simple .config file with hex ranges
    let config_path = workspace_root.join(".config");
    let config_content = r#"
PCI_RANGES=[0x0, 0x1]
MMIO_RANGES=[0x9000000, 0x1000]
FEATURES=[foo, bar]
"#;
    fs::write(&config_path, config_content).unwrap();
    
    // Parse the config
    let config = parse_config(&config_path).unwrap();
    
    // Generate config.rs
    let target_dir = workspace_root.join("target/kbuild");
    generate_config_rs(&config, &workspace_root.to_path_buf()).unwrap();
    
    // Read the generated file
    let config_rs_path = target_dir.join("config.rs");
    let generated = fs::read_to_string(&config_rs_path).unwrap();
    
    println!("Generated config.rs:\n{}", generated);
    
    // Verify hex arrays are generated as &[usize]
    assert!(generated.contains("pub const PCI_RANGES: &[usize] = &[0x0, 0x1]"), 
        "Expected PCI_RANGES to be &[usize], got:\n{}", generated);
    assert!(generated.contains("pub const MMIO_RANGES: &[usize] = &[0x9000000, 0x1000]"),
        "Expected MMIO_RANGES to be &[usize], got:\n{}", generated);
    
    // Verify string arrays are still &[&str]
    assert!(generated.contains("pub const FEATURES: &[&str] = &[\"foo\", \"bar\"]"),
        "Expected FEATURES to be &[&str], got:\n{}", generated);
}

// Helper function to parse config file
fn parse_config(path: &PathBuf) -> Result<HashMap<String, String>, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read config: {}", e))?;
    
    let mut config = HashMap::new();
    
    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        
        if let Some((key, value)) = line.split_once('=') {
            config.insert(key.trim().to_string(), value.trim().to_string());
        }
    }
    
    Ok(config)
}

// Helper function to generate config.rs - extracted from main.rs
fn generate_config_rs(config: &HashMap<String, String>, workspace_root: &PathBuf) -> Result<(), String> {
    let target_dir = workspace_root.join("target/kbuild");
    fs::create_dir_all(&target_dir)
        .map_err(|e| format!("Failed to create target/kbuild: {}", e))?;

    let config_rs_path = target_dir.join("config.rs");

    let mut content = String::new();
    content.push_str("// Auto-generated by cargo-kbuild from .config\n");
    content.push_str("// DO NOT EDIT MANUALLY\n\n");

    for (key, value) in config {
        // Skip boolean configs (y/n/m) - handled via --cfg
        if value == "y" || value == "n" || value == "m" {
            continue;
        }

        content.push_str(&format!("#[allow(dead_code)]\n"));

        // Check if it's a range value (starts with [ and ends with ])
        if value.starts_with('[') && value.ends_with(']') {
            let inner = &value[1..value.len()-1];
            
            if inner.is_empty() {
                // Empty array
                content.push_str(&format!("pub const {}: &[&str] = &[];\n\n", key));
                continue;
            }
            
            let items: Vec<&str> = inner.split(',').map(|s| s.trim()).collect();
            
            // Determine element type from first item
            let first_item = items[0];
            
            if first_item.starts_with("0x") || first_item.starts_with("0X") {
                // Hex array - parse as usize values
                let mut valid_items: Vec<String> = Vec::new();
                let mut has_invalid = false;
                for s in &items {
                    let trimmed = s.trim();
                    if trimmed.starts_with("0x") || trimmed.starts_with("0X") {
                        // Parse hex string to validate and keep original format
                        match usize::from_str_radix(&trimmed[2..], 16) {
                            Ok(_) => {
                                // Keep the hex format (0x...)
                                valid_items.push(trimmed.to_string());
                            }
                            Err(_) => {
                                eprintln!("⚠️  Warning: Invalid hex value '{}' in array {}", trimmed, key);
                                has_invalid = true;
                            }
                        }
                    } else {
                        eprintln!("⚠️  Warning: Skipping non-hex item '{}' in hex array {}", trimmed, key);
                        has_invalid = true;
                    }
                }
                if has_invalid {
                    eprintln!("⚠️  Warning: {} has mixed types - only hex values will be included", key);
                }
                content.push_str(&format!("pub const {}: &[usize] = &[{}];\n\n", 
                    key, valid_items.join(", ")));
            } else if first_item.parse::<i64>().is_ok() {
                // Integer array - validate all items are integers
                let mut valid_items: Vec<String> = Vec::new();
                let mut has_invalid = false;
                for s in &items {
                    if s.trim().parse::<i64>().is_ok() {
                        valid_items.push(s.trim().to_string());
                    } else {
                        eprintln!("⚠️  Warning: Skipping non-integer item '{}' in integer array {}", s.trim(), key);
                        has_invalid = true;
                    }
                }
                if has_invalid {
                    eprintln!("⚠️  Warning: {} has mixed types - only integer values will be included", key);
                }
                content.push_str(&format!("pub const {}: &[i64] = &[{}];\n\n", 
                    key, valid_items.join(", ")));
            } else {
                // String array - all items treated as strings
                let str_items: Vec<String> = items.iter()
                    .map(|s| format!("\"{}\"", s.trim().trim_matches('"')))
                    .collect();
                content.push_str(&format!("pub const {}: &[&str] = &[{}];\n\n", 
                    key, str_items.join(", ")));
            }
            continue;
        }

        // Check if it's a hex value (starts with 0x or 0X)
        if value.starts_with("0x") || value.starts_with("0X") {
            // Parse and validate as u64 hex
            match u64::from_str_radix(&value[2..], 16) {
                Ok(_) => {
                    content.push_str(&format!("pub const {}: u64 = {};\n\n", key, value));
                }
                Err(_) => {
                    eprintln!("⚠️  Warning: Invalid hex value for {}: {}", key, value);
                }
            }
        }
        // Try parsing as unsigned integer first
        else if let Ok(uint_val) = value.parse::<u64>() {
            content.push_str(&format!("pub const {}: u64 = {};\n\n", key, uint_val));
        }
        // Then try parsing as signed integer
        else if let Ok(int_val) = value.parse::<i64>() {
            content.push_str(&format!("pub const {}: i64 = {};\n\n", key, int_val));
        }
        // Otherwise treat as string
        else {
            content.push_str(&format!("pub const {}: &str = \"{}\";\n\n", key, value));
        }
    }

    fs::write(&config_rs_path, content).map_err(|e| format!("Failed to write config.rs: {}", e))?;

    Ok(())
}
