use std::{
    env,
    fs::{self, File},
    io::{BufRead, BufReader, Result, Write},
    path::Path,
};

macro_rules! template {
    () => {
        concat!(
            "// Generated by build.rs, DO NOT edit\n",
            "\n",
            "/// Linux specific error codes defined in `errno.h`.\n",
            "#[repr(i32)]\n",
            "#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n",
            "pub enum LinuxError {{\n",
            "{0}}}\n",
            "\n",
            "impl TryFrom<i32> for LinuxError {{\n",
            "    type Error = i32;\n",
            "\n",
            "    fn try_from(value: i32) -> Result<Self, Self::Error> {{\n",
            "        use self::LinuxError::*;\n",
            "        match value {{\n",
            "{1}            _ => Err(value),\n",
            "        }}\n",
            "    }}\n",
            "}}\n",
            "\n",
            "impl LinuxError {{\n",
            "    /// Returns the error description.\n",
            "    pub const fn as_str(&self) -> &'static str {{\n",
            "        use self::LinuxError::*;\n",
            "        match self {{\n",
            "{2}        }}\n",
            "    }}\n",
            "\n",
            "    /// Returns the error code value in `i32`.\n",
            "    pub const fn code(self) -> i32 {{\n",
            "        self as i32\n",
            "    }}\n",
            "}}\n",
        )
    };
}

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    gen_linux_errno(&Path::new(&out_dir).join("linux_errno.rs")).unwrap();
}

fn gen_linux_errno(dest_path: &Path) -> Result<()> {
    let mut enum_define = Vec::new();
    let mut try_from_i32 = Vec::new();
    let mut detail_info = Vec::new();

    let file = File::open("src/errno.h")?;
    for line in BufReader::new(file).lines().map_while(Result::ok) {
        if line.starts_with("#define") {
            let mut iter = line.split_whitespace();
            if let Some(name) = iter.nth(1) {
                if let Some(num) = iter.next() {
                    let description = if let Some(pos) = line.find("/* ") {
                        String::from(line[pos + 3..].trim_end_matches(" */"))
                    } else {
                        format!("Error number {num}")
                    };
                    writeln!(enum_define, "    /// {description}\n    {name} = {num},")?;
                    writeln!(try_from_i32, "            {num} => Ok({name}),")?;
                    writeln!(detail_info, "            {name} => \"{description}\",")?;
                }
            }
        }
    }

    fs::write(
        dest_path,
        format!(
            template!(),
            String::from_utf8_lossy(&enum_define),
            String::from_utf8_lossy(&try_from_i32),
            String::from_utf8_lossy(&detail_info)
        ),
    )?;

    Ok(())
}
